#!/usr/bin/env python3

import socket
import threading
import random
import time
import logging

from queue import Queue

from p2p.node import Node, Peer
from core import state
from core.utils import debug, info, error
from core.config import Config


logger = logging.getLogger("kakarot")

"""
TODO: Next step would be to implement ping and request/respond to find peers
      That would allow us to test all the network routing

TODO: Create cli find_node, ping etc... for easier testing
TODO: send only uuid with query,res,error message since receiver can get other details from connection
TODO: for response message, transaction_id should be positional

"""


class PeerThread(threading.Thread):
    def __init__(self, uuid: int, keyspace: int, bucket_size: int, alpha: int):
        threading.Thread.__init__(self)
        self._stopped = False
        self._keyspace = keyspace

        self._bucket_size = bucket_size
        self._uuid = uuid
        self._port = uuid
        self._alpha = alpha

        print(self._uuid, self._port)

    def is_stopped(self):
        return self._stopped

    def __repr__(self):
        return f"THREAD: {self}"

    def _get_uuid(self, max):
        """ To make testing slightly easier we use port numbers equal to the UUID's.
            This means that we should start at UUID=1024 so we don't have to run as root """
        return random.randrange(1024, 2**max)

    def _get_int_ip(self):
        return socket.gethostbyname(socket.gethostname())

    def stop(self):
        self._node.stop()

    def run(self):

        t_start = time.time()

        self._node = Node("127.0.0.1", self._port, self._keyspace, self._bucket_size, self._alpha, uuid=self._uuid)
        info("peer_thread", str(self._uuid), f"starting {self._node}")
        self._node.run()
        self._stopped = True
        t_delta = round(time.time()-t_start,1)


class ServerThreadManager():
    """ Manages a pool of threads that get new data from servers """
    def __init__(self, state: Config):
        self._bucket_size = state.bucket_size
        self._amount = state.peers
        self._keyspace = state.keyspace
        self._alpha = state.alpha
        self._pool: list[PeerThread] = []

    def stop(self):
        for t in self._pool:
            t.stop()
            t.join()
        t_elapsed = time.time() - self._t_start
        info("thread_manager", "done", f"all nodes ran in {round(t_elapsed, 1)} seconds")

    def _get_uuid(self, max):
        """ To make testing slightly easier we use port numbers equal to the UUID's.
            This means that we should start at UUID=1024 so we don't have to run as root """
        return random.randrange(1024, 2**max)

    def _pick_random(self, lst: list[Peer], amount: int):
        return [random.choice(lst) for _ in range(amount)]

    def run(self):
        debug("thread_manager", "init", f"Starting {self._amount} nodes")
        self._t_start = time.time()

        # create a list of all uuid's so we can create random bootstrap lists for every node that we start
        node_list = []

        for _ in range(self._amount):
            uuid = self._get_uuid(self._keyspace)
            peer = Peer(uuid, "127.0.0.1", uuid)
            node_list.append(peer)

            # NOTE: we use uuid as port number to make testing with large amount of nodes easier to manage
            t = PeerThread(peer.uuid, self._keyspace, self._bucket_size, self._alpha)
            self._pool.append(t)
            t.start()

        # Wait till all threads have started

        for t in self._pool:
            bootstrap_lst = self._pick_random(node_list, 1)
            t._node.bootstrap(bootstrap_lst)

        for i in range(10):
            self._pool[0]._node.req_store(f"key{i}", f"value{i}")

        time.sleep(5)
        for t in self._pool:
            print(t._node)
            print(t._node._table)
            print()

        while True:
            time.sleep(0.1)


class Kakarot():
    def __init__(self) -> None:
        ...

    def get_int_ip(self):
        return socket.gethostbyname(socket.gethostname())

    def _parse_id(self, id: str):
        try:
            target_uuid, rest = id.split("@")
            target_ip, target_port  = rest.split(":")
            target_uuid = int(target_uuid)
            target_port = int(target_port)
            return Peer(target_uuid, target_ip, target_port)
        except ValueError as e:
            error("kakarot", "do_ping", f"Failed to parse target: {state.target}, {e}")
            return

    def run_node(self, state):
        node = Node("127.0.0.1", state.port, state.keyspace, state.bucket_size, state.alpha, uuid=state.uuid)
        node.start()

        if state.bootstrap:
            if (peer := self._parse_id(state.bootstrap)) == None:
                return
            node.bootstrap([peer])

        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            node.stop()

        print("done")

    def do_ping(self, state):
        if (target := self._parse_id(state.target)) == None:
            return

        node = Node("127.0.0.1", state.port, state.keyspace, state.bucket_size, state.alpha, uuid=state.uuid)
        node.start()
        time.sleep(1)
        node.req_ping(target.uuid, target.ip, target.port)
        node.stop()

        print("done")

    def do_find_node(self, state):
        print(state.target)
        node = Node("127.0.0.1", state.port, state.keyspace, state.bucket_size, state.alpha, uuid=state.uuid)
        node.start()
        time.sleep(1)

        if state.bootstrap:
            if (peer := self._parse_id(state.bootstrap)) == None:
                return
            node.bootstrap([peer])

        for target in state.target:
            node.req_find_node(target)

        node.stop()

        print("done")

    def do_find_key(self, state):
        node = Node("127.0.0.1", state.port, state.keyspace, state.bucket_size, state.alpha, uuid=state.uuid)
        node.start()
        time.sleep(1)
        if state.bootstrap:
            if (peer := self._parse_id(state.bootstrap)) == None:
                return
            node.bootstrap([peer])
            node.req_find_value(state.key)
            # do stuff
        node.stop()

    def do_store(self, state):
        node = Node("127.0.0.1", state.port, state.keyspace, state.bucket_size, state.alpha, uuid=state.uuid)
        node.start()
        time.sleep(1)
        if state.bootstrap:
            if (peer := self._parse_id(state.bootstrap)) == None:
                return
            node.bootstrap([peer])
            node.req_store(state.key, state.value)
            # do stuff
        node.stop()

    def run(self, state):
        if state.do_test:
            tm = ServerThreadManager(state)
            try:
                tm.run()
            except KeyboardInterrupt:
                tm.stop()

        elif state.do_run:
            self.run_node(state)

        elif state.do_ping:
            self.do_ping(state)
        elif state.do_find_node:
            self.do_find_node(state)
        elif state.do_find_key:
            self.do_find_key(state)
        elif state.do_store:
            self.do_store(state)



if __name__ == "__main__":
    kakarot = Kakarot()
    kakarot.run(state)
